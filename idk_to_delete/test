import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import cv2
import numpy as np
from PIL import Image, ImageTk
import win32gui
import threading
import time
import os
from plyer import notification
import winsound
import mss
import ctypes
import win32con


# ---------------- DPI / Windows helpers ----------------

def set_process_dpi_awareness():
    """Try to make the process DPI aware so coordinates map 1:1 with screen pixels."""
    try:
        # Windows 10+ per-monitor aware
        shcore = ctypes.windll.shcore
        shcore.SetProcessDpiAwareness(2)
    except Exception:
        try:
            # Older fallback
            ctypes.windll.user32.SetProcessDPIAware()
        except Exception:
            pass


def client_rect_to_screen(hwnd):
    """Return client-area screen coordinates (left, top, right, bottom).

    Uses ClientToScreen so we capture the inside of the window (no title bar/borders).
    """
    try:
        # Get client rect in window coordinates (usually left=0, top=0, right=width, bottom=height)
        l, t, r, b = win32gui.GetClientRect(hwnd)
        # Convert client coords to screen coords
        left_top = win32gui.ClientToScreen(hwnd, (l, t))
        right_bottom = win32gui.ClientToScreen(hwnd, (r, b))
        left, top = left_top
        right, bottom = right_bottom
        return int(left), int(top), int(right), int(bottom)
    except Exception:
        return None


# Make process DPI aware early
set_process_dpi_awareness()


class DialogDetectorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Blue Archive Dialog Detector üå∏ (MSS Version)")
        self.root.geometry("600x800")

        # State
        self.running = False
        self.selected_window_hwnd = None
        self.template_img = None
        self.monitor_thread = None
        self.scan_interval = 2.0
        self.confidence_threshold = 0.8
        self.alert_cooldown = 5.0
        self._last_alert_time = 0

        # UI
        frame_top = ttk.LabelFrame(root, text="1. Select Game Window")
        frame_top.pack(fill="x", padx=10, pady=5)

        self.window_combo = ttk.Combobox(frame_top, state="readonly")
        self.window_combo.pack(side="left", fill="x", expand=True, padx=5, pady=5)
        self.window_combo.bind("<<ComboboxSelected>>", self.on_window_select)

        btn_refresh = ttk.Button(frame_top, text="üîÑ Refresh List", command=self.refresh_windows)
        btn_refresh.pack(side="right", padx=5)

        btn_preview = ttk.Button(frame_top, text="üñºÔ∏è Refresh Preview", command=self.refresh_preview)
        btn_preview.pack(side="right", padx=5)

        # Preview
        self.preview_frame = ttk.LabelFrame(root, text="2. Confirmation Preview")
        self.preview_frame.pack(fill="both", expand=True, padx=10, pady=5)

        self.canvas = tk.Canvas(self.preview_frame, bg="#2b2b2b")
        self.canvas.pack(fill="both", expand=True, padx=5, pady=5)
        self.canvas_text = self.canvas.create_text(
            290, 150,
            text="Select window above!\n(Window MUST be visible on screen)",
            fill="white", justify="center"
        )

        # Controls
        frame_controls = ttk.LabelFrame(root, text="3. Controls")
        frame_controls.pack(fill="x", padx=10, pady=5)

        btn_template = ttk.Button(frame_controls, text="‚úÇÔ∏è Create Template", command=self.open_crop_tool)
        btn_template.pack(side="left", padx=5, pady=10)

        self.lbl_template_status = ttk.Label(frame_controls, text="No template loaded ‚ùå", foreground="red")
        self.lbl_template_status.pack(side="left", padx=5)

        self.btn_monitor = ttk.Button(frame_controls, text="‚ñ∂Ô∏è Start Monitoring", command=self.toggle_monitoring, state="disabled")
        self.btn_monitor.pack(side="right", padx=5, pady=10)

        # Logs
        frame_log = ttk.LabelFrame(root, text="Activity Log")
        frame_log.pack(fill="x", padx=10, pady=5)
        self.log_var = tk.StringVar(value="Ready! Select your Blue Archive window to start.")
        ttk.Label(frame_log, textvariable=self.log_var).pack(anchor="w", padx=5, pady=5)

        # Initial
        self.refresh_windows()

    # Thread-safe logging
    def log(self, msg):
        def _set():
            self.log_var.set(msg)
        try:
            self.root.after(0, _set)
        except Exception:
            # If called before root mainloop, fallback
            self.log_var.set(msg)

    # ---- Window enumeration & capture ----
    def get_windows_dict(self):
        windows = {}

        def callback(hwnd, _):
            try:
                if win32gui.IsWindowVisible(hwnd) and win32gui.GetWindowText(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    windows[title] = hwnd
            except Exception:
                pass

        win32gui.EnumWindows(callback, None)
        return windows

    def ensure_window_visible(self, hwnd, restore_if_minimized=True, wait_secs=0.15):
        """Ensure target window is restored and foregrounded before capture."""
        try:
            if not win32gui.IsWindow(hwnd):
                self.log("Target window handle invalid.")
                return False

            if restore_if_minimized and win32gui.IsIconic(hwnd):
                try:
                    win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
                except Exception:
                    pass

            try:
                win32gui.SetForegroundWindow(hwnd)
            except Exception:
                pass

            time.sleep(wait_secs)
            return True
        except Exception as e:
            self.log(f"ensure_window_visible error: {e}")
            return False


    def refresh_windows(self):
        self.windows_map = self.get_windows_dict()
        self.window_combo['values'] = list(self.windows_map.keys())
        self.log("Window list refreshed.")

    def capture_window_area(self, hwnd):
        """Capture the client area of the given window using MSS (thread-safe)."""
        try:
            if not win32gui.IsWindow(hwnd):
                self.log("Selected window is no longer valid.")
                return None

            if win32gui.IsIconic(hwnd):
                self.log("Window is minimized ‚Äî please restore it.")
                return None

            rect = client_rect_to_screen(hwnd)
            if rect is None:
                x1, y1, x2, y2 = win32gui.GetWindowRect(hwnd)
            else:
                x1, y1, x2, y2 = rect

            w = x2 - x1
            h = y2 - y1
            if w <= 0 or h <= 0:
                return None

            monitor = {
                "top": int(y1),
                "left": int(x1),
                "width": int(w),
                "height": int(h),
            }

            # ‚úÖ MSS CREATED PER CALL ‚Üí THREAD SAFE
            with mss.mss() as sct:
                sct_img = sct.grab(monitor)

            img = np.array(sct_img)
            if img.shape[2] == 4:
                img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

            return img

        except Exception as e:
            self.log(f"Capture failed: {e}")
            return None


    # UI callbacks
    def on_window_select(self, event):
        title = self.window_combo.get()
        if title in self.windows_map:
            self.selected_window_hwnd = self.windows_map[title]
            # Try to bring to front (best-effort)
            try:
                win32gui.SetForegroundWindow(self.selected_window_hwnd)
                time.sleep(0.1)
            except Exception:
                pass

            frame = self.capture_window_area(self.selected_window_hwnd)
            if frame is not None:
                self.show_preview(frame)
                self.log(f"‚úÖ Preview loaded for: {title}")
            else:
                self.log("‚ùå Capture failed. Ensure the window is visible and not minimized.")

    def refresh_preview(self):
        if not self.selected_window_hwnd:
            self.log("No window selected to refresh preview.")
            return

        # Force window to be restored + foregrounded
        self.ensure_window_visible(self.selected_window_hwnd)

        frame = self.capture_window_area(self.selected_window_hwnd)

        # Detect desktop grab (common MSS failure mode)
        if frame is not None:
            try:
                h, w = frame.shape[:2]

                with mss.mss() as sct:
                    mon = sct.monitors[0] # full virtual desktop
                if w == mon["width"] and h == mon["height"]:
                    self.log("‚ö†Ô∏è Desktop captured ‚Äî retrying after foregrounding window...")
                    self.ensure_window_visible(self.selected_window_hwnd, wait_secs=0.2)
                    frame = self.capture_window_area(self.selected_window_hwnd)
            except Exception:
                pass

        if frame is not None:
            self.show_preview(frame)
            self.log("Preview refreshed.")
        else:
            self.log("Preview refresh failed. Ensure the window is visible and not minimized.")


    def show_preview(self, cv_img):
        # Convert for Tk
        cv_img_rgb = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        pil_img = Image.fromarray(cv_img_rgb)

        c_w = self.canvas.winfo_width()
        c_h = self.canvas.winfo_height()
        if c_w < 10:
            c_w, c_h = 580, 400

        img_w, img_h = pil_img.size
        ratio = min(c_w / img_w, c_h / img_h)
        new_size = (max(1, int(img_w * ratio)), max(1, int(img_h * ratio)))
        pil_img = pil_img.resize(new_size, Image.Resampling.LANCZOS)
        self.tk_image = ImageTk.PhotoImage(pil_img)

        self.canvas.delete("all")
        self.canvas.create_image(c_w // 2, c_h // 2, image=self.tk_image, anchor="center")

    # -- Crop tool --
    def open_crop_tool(self):
        if not self.selected_window_hwnd:
            messagebox.showwarning("Wait", "Please select the game window first!")
            return

        frame = self.capture_window_area(self.selected_window_hwnd)
        if frame is None:
            messagebox.showerror("Error", "Could not capture game for cropping. Make sure the window is visible/not minimized.")
            return

        # Save a temp PNG and open a scrollable canvas so coordinates match the captured pixels
        temp_path = "temp_crop.png"
        cv2.imwrite(temp_path, frame)

        raw_img = Image.open(temp_path)
        img_w, img_h = raw_img.size

        top = tk.Toplevel(self.root)
        top.title("Drag to Select Template Area")

        # Scrollable Canvas
        canvas_frame = ttk.Frame(top)
        canvas_frame.pack(fill="both", expand=True)
        hbar = ttk.Scrollbar(canvas_frame, orient="horizontal")
        vbar = ttk.Scrollbar(canvas_frame, orient="vertical")
        canvas = tk.Canvas(canvas_frame, cursor="cross", xscrollcommand=hbar.set, yscrollcommand=vbar.set)
        hbar.config(command=canvas.xview)
        vbar.config(command=canvas.yview)
        hbar.pack(side="bottom", fill="x")
        vbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)

        tk_img = ImageTk.PhotoImage(raw_img)
        canvas.create_image(0, 0, image=tk_img, anchor="nw")
        canvas.config(scrollregion=(0, 0, img_w, img_h))

        rect_data = {"start_x": 0, "start_y": 0, "rect_id": None}

        def on_mouse_down(event):
            rect_data["start_x"] = canvas.canvasx(event.x)
            rect_data["start_y"] = canvas.canvasy(event.y)

        def on_mouse_drag(event):
            cur_x, cur_y = canvas.canvasx(event.x), canvas.canvasy(event.y)
            if rect_data["rect_id"]:
                canvas.delete(rect_data["rect_id"])
            rect_data["rect_id"] = canvas.create_rectangle(
                rect_data["start_x"], rect_data["start_y"], cur_x, cur_y, outline="#00ff00", width=2)

        def on_mouse_up(event):
            x1, y1 = rect_data["start_x"], rect_data["start_y"]
            x2, y2 = canvas.canvasx(event.x), canvas.canvasy(event.y)
            left, top_c = int(min(x1, x2)), int(min(y1, y2))
            right, bottom_c = int(max(x1, x2)), int(max(y1, y2))

            if right - left < 5 or bottom_c - top_c < 5:
                return

            cropped = raw_img.crop((left, top_c, right, bottom_c))
            cropped.save("template.png")

            tmpl = cv2.imread("template.png", 0)
            if tmpl is None:
                messagebox.showerror("Error", "Failed to load template after saving.")
                return
            self.template_img = tmpl
            self.lbl_template_status.config(text="Template loaded ‚úÖ", foreground="green")
            self.btn_monitor.config(state="normal")
            top.destroy()
            messagebox.showinfo("Success", "Template saved! Now click Start Monitoring.")

        canvas.bind("<ButtonPress-1>", on_mouse_down)
        canvas.bind("<B1-Motion>", on_mouse_drag)
        canvas.bind("<ButtonRelease-1>", on_mouse_up)
        canvas.image = tk_img

    # --- Monitoring ---
    def toggle_monitoring(self):
        if not self.running:
            if not self.selected_window_hwnd:
                messagebox.showwarning("No window", "Select a game window first.")
                return
            if self.template_img is None:
                messagebox.showwarning("No template", "Create/load a template first.")
                return

            self.running = True
            self.btn_monitor.config(text="‚èπÔ∏è Stop Monitoring")
            self.log("Monitoring started...")
            self.monitor_thread = threading.Thread(target=self.monitor_loop, daemon=True)
            self.monitor_thread.start()
        else:
            self.running = False
            self.btn_monitor.config(text="‚ñ∂Ô∏è Start Monitoring")
            self.log("Monitoring stopped.")

    def monitor_loop(self):
        while self.running:
            try:
                if not win32gui.IsWindow(self.selected_window_hwnd):
                    self.log("Target window closed. Stopping monitor.")
                    self.running = False
                    break

                screen = self.capture_window_area(self.selected_window_hwnd)
                if screen is None:
                    time.sleep(1)
                    continue

                screen_gray = cv2.cvtColor(screen, cv2.COLOR_BGR2GRAY)
                res = cv2.matchTemplate(screen_gray, self.template_img, cv2.TM_CCOEFF_NORMED)
                _, max_val, _, _ = cv2.minMaxLoc(res)

                now = time.time()
                if max_val >= self.confidence_threshold and (now - self._last_alert_time) >= self.alert_cooldown:
                    self._last_alert_time = now
                    self.trigger_alert()

            except Exception as e:
                # Print to console, also log to UI
                print(f"Monitor Error: {e}")
                self.log(f"Monitor error: {e}")

            time.sleep(self.scan_interval)

    def trigger_alert(self):
        self.log("‚ö†Ô∏è MATCH FOUND! Sending alert...")
        try:
            winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
        except Exception:
            pass
        try:
            notification.notify(title="Dialog Detected!", message="Click now!", timeout=5)
        except Exception:
            pass


if __name__ == "__main__":
    # Try to set DPI awareness again in case module import order mattered
    try:
        set_process_dpi_awareness()
    except: pass

    root = tk.Tk()
    app = DialogDetectorApp(root)
    root.mainloop()
